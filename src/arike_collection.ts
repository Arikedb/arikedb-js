/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.21.12
 * source: arike_collection.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./arike_utils";
import * as pb_1 from "google-protobuf";
export namespace arike_pb {
    export class CollectionMeta extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            name?: string;
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("name" in data && data.name != undefined) {
                    this.name = data.name;
                }
            }
        }
        get name() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set name(value: string) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            name?: string;
        }): CollectionMeta {
            const message = new CollectionMeta({});
            if (data.name != null) {
                message.name = data.name;
            }
            return message;
        }
        toObject() {
            const data: {
                name?: string;
            } = {};
            if (this.name != null) {
                data.name = this.name;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.name.length)
                writer.writeString(1, this.name);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CollectionMeta {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CollectionMeta();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.name = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CollectionMeta {
            return CollectionMeta.deserialize(bytes);
        }
    }
    export class CreateCollectionsRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            collections?: CollectionMeta[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("collections" in data && data.collections != undefined) {
                    this.collections = data.collections;
                }
            }
        }
        get collections() {
            return pb_1.Message.getRepeatedWrapperField(this, CollectionMeta, 1) as CollectionMeta[];
        }
        set collections(value: CollectionMeta[]) {
            pb_1.Message.setRepeatedWrapperField(this, 1, value);
        }
        static fromObject(data: {
            collections?: ReturnType<typeof CollectionMeta.prototype.toObject>[];
        }): CreateCollectionsRequest {
            const message = new CreateCollectionsRequest({});
            if (data.collections != null) {
                message.collections = data.collections.map(item => CollectionMeta.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                collections?: ReturnType<typeof CollectionMeta.prototype.toObject>[];
            } = {};
            if (this.collections != null) {
                data.collections = this.collections.map((item: CollectionMeta) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.collections.length)
                writer.writeRepeatedMessage(1, this.collections, (item: CollectionMeta) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CreateCollectionsRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CreateCollectionsRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        reader.readMessage(message.collections, () => pb_1.Message.addToRepeatedWrapperField(message, 1, CollectionMeta.deserialize(reader), CollectionMeta));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CreateCollectionsRequest {
            return CreateCollectionsRequest.deserialize(bytes);
        }
    }
    export class CreateCollectionsResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            status?: dependency_1.arike_pb.StatusCode;
            already_exists?: string[];
            license_exceeded?: string[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2, 3], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("status" in data && data.status != undefined) {
                    this.status = data.status;
                }
                if ("already_exists" in data && data.already_exists != undefined) {
                    this.already_exists = data.already_exists;
                }
                if ("license_exceeded" in data && data.license_exceeded != undefined) {
                    this.license_exceeded = data.license_exceeded;
                }
            }
        }
        get status() {
            return pb_1.Message.getFieldWithDefault(this, 1, dependency_1.arike_pb.StatusCode.OK) as dependency_1.arike_pb.StatusCode;
        }
        set status(value: dependency_1.arike_pb.StatusCode) {
            pb_1.Message.setField(this, 1, value);
        }
        get already_exists() {
            return pb_1.Message.getFieldWithDefault(this, 2, []) as string[];
        }
        set already_exists(value: string[]) {
            pb_1.Message.setField(this, 2, value);
        }
        get license_exceeded() {
            return pb_1.Message.getFieldWithDefault(this, 3, []) as string[];
        }
        set license_exceeded(value: string[]) {
            pb_1.Message.setField(this, 3, value);
        }
        static fromObject(data: {
            status?: dependency_1.arike_pb.StatusCode;
            already_exists?: string[];
            license_exceeded?: string[];
        }): CreateCollectionsResponse {
            const message = new CreateCollectionsResponse({});
            if (data.status != null) {
                message.status = data.status;
            }
            if (data.already_exists != null) {
                message.already_exists = data.already_exists;
            }
            if (data.license_exceeded != null) {
                message.license_exceeded = data.license_exceeded;
            }
            return message;
        }
        toObject() {
            const data: {
                status?: dependency_1.arike_pb.StatusCode;
                already_exists?: string[];
                license_exceeded?: string[];
            } = {};
            if (this.status != null) {
                data.status = this.status;
            }
            if (this.already_exists != null) {
                data.already_exists = this.already_exists;
            }
            if (this.license_exceeded != null) {
                data.license_exceeded = this.license_exceeded;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.status != dependency_1.arike_pb.StatusCode.OK)
                writer.writeEnum(1, this.status);
            if (this.already_exists.length)
                writer.writeRepeatedString(2, this.already_exists);
            if (this.license_exceeded.length)
                writer.writeRepeatedString(3, this.license_exceeded);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): CreateCollectionsResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new CreateCollectionsResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.status = reader.readEnum();
                        break;
                    case 2:
                        pb_1.Message.addToRepeatedField(message, 2, reader.readString());
                        break;
                    case 3:
                        pb_1.Message.addToRepeatedField(message, 3, reader.readString());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): CreateCollectionsResponse {
            return CreateCollectionsResponse.deserialize(bytes);
        }
    }
    export class DeleteCollectionsRequest extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            names?: string[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [1], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("names" in data && data.names != undefined) {
                    this.names = data.names;
                }
            }
        }
        get names() {
            return pb_1.Message.getFieldWithDefault(this, 1, []) as string[];
        }
        set names(value: string[]) {
            pb_1.Message.setField(this, 1, value);
        }
        static fromObject(data: {
            names?: string[];
        }): DeleteCollectionsRequest {
            const message = new DeleteCollectionsRequest({});
            if (data.names != null) {
                message.names = data.names;
            }
            return message;
        }
        toObject() {
            const data: {
                names?: string[];
            } = {};
            if (this.names != null) {
                data.names = this.names;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.names.length)
                writer.writeRepeatedString(1, this.names);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DeleteCollectionsRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new DeleteCollectionsRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        pb_1.Message.addToRepeatedField(message, 1, reader.readString());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): DeleteCollectionsRequest {
            return DeleteCollectionsRequest.deserialize(bytes);
        }
    }
    export class DeleteCollectionsResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            status?: dependency_1.arike_pb.StatusCode;
            not_found?: string[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("status" in data && data.status != undefined) {
                    this.status = data.status;
                }
                if ("not_found" in data && data.not_found != undefined) {
                    this.not_found = data.not_found;
                }
            }
        }
        get status() {
            return pb_1.Message.getFieldWithDefault(this, 1, dependency_1.arike_pb.StatusCode.OK) as dependency_1.arike_pb.StatusCode;
        }
        set status(value: dependency_1.arike_pb.StatusCode) {
            pb_1.Message.setField(this, 1, value);
        }
        get not_found() {
            return pb_1.Message.getFieldWithDefault(this, 2, []) as string[];
        }
        set not_found(value: string[]) {
            pb_1.Message.setField(this, 2, value);
        }
        static fromObject(data: {
            status?: dependency_1.arike_pb.StatusCode;
            not_found?: string[];
        }): DeleteCollectionsResponse {
            const message = new DeleteCollectionsResponse({});
            if (data.status != null) {
                message.status = data.status;
            }
            if (data.not_found != null) {
                message.not_found = data.not_found;
            }
            return message;
        }
        toObject() {
            const data: {
                status?: dependency_1.arike_pb.StatusCode;
                not_found?: string[];
            } = {};
            if (this.status != null) {
                data.status = this.status;
            }
            if (this.not_found != null) {
                data.not_found = this.not_found;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.status != dependency_1.arike_pb.StatusCode.OK)
                writer.writeEnum(1, this.status);
            if (this.not_found.length)
                writer.writeRepeatedString(2, this.not_found);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DeleteCollectionsResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new DeleteCollectionsResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.status = reader.readEnum();
                        break;
                    case 2:
                        pb_1.Message.addToRepeatedField(message, 2, reader.readString());
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): DeleteCollectionsResponse {
            return DeleteCollectionsResponse.deserialize(bytes);
        }
    }
    export class ListCollectionsRequest extends pb_1.Message {
        #one_of_decls: number[][] = [[1]];
        constructor(data?: any[] | ({} & (({
            pattern?: string;
        })))) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("pattern" in data && data.pattern != undefined) {
                    this.pattern = data.pattern;
                }
            }
        }
        get pattern() {
            return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
        }
        set pattern(value: string) {
            pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
        }
        get has_pattern() {
            return pb_1.Message.getField(this, 1) != null;
        }
        get _pattern() {
            const cases: {
                [index: number]: "none" | "pattern";
            } = {
                0: "none",
                1: "pattern"
            };
            return cases[pb_1.Message.computeOneofCase(this, [1])];
        }
        static fromObject(data: {
            pattern?: string;
        }): ListCollectionsRequest {
            const message = new ListCollectionsRequest({});
            if (data.pattern != null) {
                message.pattern = data.pattern;
            }
            return message;
        }
        toObject() {
            const data: {
                pattern?: string;
            } = {};
            if (this.pattern != null) {
                data.pattern = this.pattern;
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.has_pattern)
                writer.writeString(1, this.pattern);
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ListCollectionsRequest {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ListCollectionsRequest();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.pattern = reader.readString();
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ListCollectionsRequest {
            return ListCollectionsRequest.deserialize(bytes);
        }
    }
    export class ListCollectionsResponse extends pb_1.Message {
        #one_of_decls: number[][] = [];
        constructor(data?: any[] | {
            status?: dependency_1.arike_pb.StatusCode;
            collections?: CollectionMeta[];
        }) {
            super();
            pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [2], this.#one_of_decls);
            if (!Array.isArray(data) && typeof data == "object") {
                if ("status" in data && data.status != undefined) {
                    this.status = data.status;
                }
                if ("collections" in data && data.collections != undefined) {
                    this.collections = data.collections;
                }
            }
        }
        get status() {
            return pb_1.Message.getFieldWithDefault(this, 1, dependency_1.arike_pb.StatusCode.OK) as dependency_1.arike_pb.StatusCode;
        }
        set status(value: dependency_1.arike_pb.StatusCode) {
            pb_1.Message.setField(this, 1, value);
        }
        get collections() {
            return pb_1.Message.getRepeatedWrapperField(this, CollectionMeta, 2) as CollectionMeta[];
        }
        set collections(value: CollectionMeta[]) {
            pb_1.Message.setRepeatedWrapperField(this, 2, value);
        }
        static fromObject(data: {
            status?: dependency_1.arike_pb.StatusCode;
            collections?: ReturnType<typeof CollectionMeta.prototype.toObject>[];
        }): ListCollectionsResponse {
            const message = new ListCollectionsResponse({});
            if (data.status != null) {
                message.status = data.status;
            }
            if (data.collections != null) {
                message.collections = data.collections.map(item => CollectionMeta.fromObject(item));
            }
            return message;
        }
        toObject() {
            const data: {
                status?: dependency_1.arike_pb.StatusCode;
                collections?: ReturnType<typeof CollectionMeta.prototype.toObject>[];
            } = {};
            if (this.status != null) {
                data.status = this.status;
            }
            if (this.collections != null) {
                data.collections = this.collections.map((item: CollectionMeta) => item.toObject());
            }
            return data;
        }
        serialize(): Uint8Array;
        serialize(w: pb_1.BinaryWriter): void;
        serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
            const writer = w || new pb_1.BinaryWriter();
            if (this.status != dependency_1.arike_pb.StatusCode.OK)
                writer.writeEnum(1, this.status);
            if (this.collections.length)
                writer.writeRepeatedMessage(2, this.collections, (item: CollectionMeta) => item.serialize(writer));
            if (!w)
                return writer.getResultBuffer();
        }
        static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ListCollectionsResponse {
            const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ListCollectionsResponse();
            while (reader.nextField()) {
                if (reader.isEndGroup())
                    break;
                switch (reader.getFieldNumber()) {
                    case 1:
                        message.status = reader.readEnum();
                        break;
                    case 2:
                        reader.readMessage(message.collections, () => pb_1.Message.addToRepeatedWrapperField(message, 2, CollectionMeta.deserialize(reader), CollectionMeta));
                        break;
                    default: reader.skipField();
                }
            }
            return message;
        }
        serializeBinary(): Uint8Array {
            return this.serialize();
        }
        static deserializeBinary(bytes: Uint8Array): ListCollectionsResponse {
            return ListCollectionsResponse.deserialize(bytes);
        }
    }
}
